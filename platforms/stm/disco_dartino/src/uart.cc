// Copyright (c) 2015, the Dartino project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE.md file.

#include "platforms/stm/disco_dartino/src/uart.h"

#include <stdlib.h>

#include <stm32f7xx_hal.h>

#include "src/shared/atomic.h"
#include "src/shared/utils.h"
#include "src/shared/platform.h"

#include "src/vm/hash_map.h"

// Reference to the instance in the code generated by STM32CubeMX.
extern UART_HandleTypeDef huart1;

// Bits set from interrupt handlers.
const int kReceivedBit = 1 << 0;
const int kTransmittedBit = 1 << 1;
const int kErrorBit = 1 << 2;

const int kRxBufferSize = 511;
const int kTxBufferSize = 511;

Uart::Uart() : device_(this) {
  uart_ = &huart1;
  read_buffer_ = new CircularBuffer(kRxBufferSize);
  write_buffer_ = new CircularBuffer(kTxBufferSize);
  tx_pending_ = false;
  interrupt_flags.store(0);
  tx_mutex_ = dartino::Platform::CreateMutex();

  osSemaphoreDef(uart_semaphore);
  semaphore_ = osSemaphoreCreate(osSemaphore(uart_semaphore), 3);
}

dartino::HashMap<UART_HandleTypeDef*, Uart*> openUarts =
    dartino::HashMap<UART_HandleTypeDef*, Uart*>();

static void UartTask(const void *arg) {
  const_cast<Uart*>(reinterpret_cast<const Uart*>(arg))->Task();
}

int Uart::Open() {
  handle_ = dartino::DeviceManager::GetDeviceManager()->InstallDevice(&device_);
  openUarts[uart_] = this;
  osThreadDef(UART_TASK, UartTask, osPriorityHigh, 0, 1024);
  osThreadCreate(osThread(UART_TASK), reinterpret_cast<void*>(this));
  // Start receiving.
  HAL_UART_Receive_IT(uart_, &read_data_, 1);
  // We are ready to write.
  device_.SetFlag(kTransmittedBit);
  return handle_;
}

size_t Uart::Read(uint8_t* buffer, size_t count) {
  int c = read_buffer_->Read(buffer, count, CircularBuffer::kDontBlock);
  if (read_buffer_->IsEmpty()) {
    device_.ClearFlag(kReceivedBit);
  }
  return c;
}

size_t Uart::Write(const uint8_t* buffer, size_t offset, size_t count) {
  size_t written_count =
      write_buffer_->Write(buffer + offset, count, CircularBuffer::kDontBlock);
  if (written_count > 0) {
    dartino::ScopedLock lock(tx_mutex_);
    EnsureTransmission();
  }
  return written_count;
}

uint32_t Uart::GetError() {
  device_.ClearFlag(kErrorBit);
  return error_;
}

void Uart::Task() {
  // Process notifications from the interrupt handlers.
  for (;;) {
    // Wait for an event to process.
    osSemaphoreWait(semaphore_, osWaitForever);
    uint32_t flags = interrupt_flags.exchange(0);
    if ((flags & kReceivedBit) != 0) {
      // Don't block when writing to the buffer. Buffer overrun will
      // cause lost data.
      read_buffer_->Write(&read_data_, 1, CircularBuffer::kDontBlock);
      device_.SetFlag(kReceivedBit);
      HAL_StatusTypeDef status = HAL_UART_Receive_IT(uart_, &read_data_, 1);
      if (status != HAL_OK) {
        dartino::Print::Error("HAL_UART_Receive_IT returned %d\n", status);
      }
    }
    if ((flags & kTransmittedBit) != 0) {
      dartino::ScopedLock lock(tx_mutex_);
      tx_pending_ = false;
      EnsureTransmission();
    }
    // This will send a message, if there currently is an eligible listener.
    device_.SetFlag(flags);
  }
}

void Uart::EnsureTransmission() {
  if (!tx_pending_) {
    // Don't block when there is nothing to send.
    int bytes = write_buffer_->Read(
        tx_data_, kTxBlockSize, CircularBuffer::kDontBlock);
    if (bytes > 0) {
      HAL_StatusTypeDef status = HAL_UART_Transmit_IT(uart_, tx_data_, bytes);
      if (status != HAL_OK) {
        dartino::Print::Error("HAL_UART_Transmit_IT returned %d\n", status);
      }
      tx_pending_ = true;
    }
    if (write_buffer_->IsFull()) {
      device_.ClearFlag(kTransmittedBit);
    }
  }
}

Uart *GetUart(int handle) {
  return reinterpret_cast<Uart*>(
      dartino::DeviceManager::GetDeviceManager()->GetDevice(handle)->GetData());
}

// Shared return from interrupt handler. Will set the specified flag
// and transfer control to the event handler.
void Uart::ReturnFromInterrupt(uint32_t flag) {
  // Set the requested bit.
  uint32_t flags = interrupt_flags;
  bool success = false;
  while (!success) {
    uint32_t new_flags = flags | flag;
    success = interrupt_flags.compare_exchange_weak(flags, new_flags);
  }

  // Pass control to the thread handling interrupts.
  portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
  osSemaphoreRelease(semaphore_);
  portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
}

extern "C" void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
  Uart *uart = openUarts[huart];
  uart->ReturnFromInterrupt(kReceivedBit);
}

extern "C" void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
  Uart *uart = openUarts[huart];
  uart->ReturnFromInterrupt(kTransmittedBit);
}

extern "C" void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
  Uart *uart = openUarts[huart];
  uart->error_ = HAL_UART_GetError(huart);
  // Clear all errors.
  __HAL_UART_CLEAR_OREFLAG(huart);
  __HAL_UART_CLEAR_FEFLAG(huart);
  __HAL_UART_CLEAR_PEFLAG(huart);
  __HAL_UART_CLEAR_NEFLAG(huart);

  uart->ReturnFromInterrupt(kErrorBit);
}
